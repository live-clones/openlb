/*  Lattice Boltzmann sample, written in C++, using the OpenLB
 *  library
 *
 *  Copyright (C) 2025 Florian Kaiser
 *                2008 Orestis Malaspinas, Andrea Parmigiani
 *  E-mail contact: info@openlb.net
 *  The most recent release of OpenLB can be downloaded at
 *  <http://www.openlb.net/>
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public
 *  License along with this program; if not, write to the Free
 *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 *  Boston, MA  02110-1301, USA.
 */

/* rayleighTaylor2d.cpp:
 * Rayleigh-Taylor instability in 2D, generated by a heavy
 * fluid penetrating a light one. The multi-component fluid model
 * by X. Shan and H. Chen is used. This example shows the usage
 * of multicomponent flow and periodic boundaries.
 */


#include <olb.h>

using namespace olb;
using namespace olb::names;

// === Step 1: Declarations ===
using MyCase = Case<
  Component1, Lattice<float,
                        descriptors::D2Q9<descriptors::FORCE,
                        descriptors::EXTERNAL_FORCE,
                        descriptors::STATISTIC>>,
  Component2, Lattice<float,
                        descriptors::D2Q9<descriptors::FORCE,
                        descriptors::EXTERNAL_FORCE,
                        descriptors::STATISTIC>>
>;

/// @brief Create a simulation mesh, based on user-specific geometry
/// @return An instance of Mesh, which keeps the relevant information
Mesh<MyCase::value_t,MyCase::d> createMesh(MyCase::ParametersD& parameters) {
  using T = MyCase::value_t_of<Component1>;
  const Vector extent = parameters.get<parameters::DOMAIN_EXTENT>();
  const Vector origin = parameters.get<parameters::ORIGIN>();
  const T physDeltaX  = parameters.get<parameters::PHYS_DELTA_X>();
  IndicatorCuboid2D<T> cuboid(extent, origin);

  Mesh<T,MyCase::d> mesh(cuboid, physDeltaX, singleton::mpi().getSize());
  mesh.setOverlap(parameters.get<parameters::OVERLAP>());
  mesh.getCuboidDecomposition().setPeriodicity({true, false});
  return mesh;
}

void prepareGeometry(MyCase& myCase) {
  OstreamManager clout( std::cout,"prepareGeometry" );
  clout << "Prepare Geometry ..." << std::endl;

  using T = MyCase::value_t_of<Component1>;

  auto& geometry    = myCase.getGeometry();
  auto& parameters  = myCase.getParameters();

  const Vector extend     = parameters.get<parameters::DOMAIN_EXTENT>();
  const T dx         = parameters.get<parameters::PHYS_DELTA_X>();
  const T nx              = extend[0];
  const T ny              = extend[1];

  // Sets material number for fluid and boundary
  geometry.rename( 0, 1 );

  Vector<T,2> originUpper( -dx, ny / 2. );
  Vector<T,2> extendUpper( nx + 2. * dx, ny / 2. + 2. * dx );
  IndicatorCuboid2D<T> upper( extendUpper, originUpper );
  geometry.rename( 1, 2, upper );

  Vector<T,2> originTop( -dx, ny - dx / 2.);
  Vector<T,2> extendTop( nx + 2. * dx, dx );
  IndicatorCuboid2D<T> top( extendTop, originTop );
  geometry.rename( 2, 4, top );

  Vector<T,2> originBottom( -dx, -dx / 2. );
  Vector<T,2> extendBottom( nx + 2. * dx, dx );
  IndicatorCuboid2D<T> bottom( extendBottom, originBottom );
  geometry.rename( 1, 3, bottom );

  geometry.checkForErrors();

  geometry.print();

  clout << "Prepare Geometry ... OK" << std::endl;
}

void prepareLattice(MyCase& myCase) {
  OstreamManager clout(std::cout,"prepareLattice");
  clout << "Prepare Lattice ..." << std::endl;

  using T          = MyCase::value_t_of<Component1>;
  using DESCRIPTOR = MyCase::descriptor_t_of<Component1>;

  auto& geometry   = myCase.getGeometry();
  auto& latticeOne = myCase.getLattice(Component1{});
  auto& latticeTwo = myCase.getLattice(Component2{});
  auto& parameters = myCase.getParameters();

  // The setup is: periodicity along horizontal direction, bounce-back on top
  // and bottom. The upper half is initially filled with fluid 1 + random noise,
  // and the lower half with fluid 2. Only fluid 1 experiences a forces,
  // directed downwards.

  const int N               = parameters.get<parameters::RESOLUTION>();
  const T tau               = parameters.get<parameters::LATTICE_RELAXATION_TIME>();
  const T physCharLength    = parameters.get<parameters::PHYS_CHAR_LENGTH>();
  const T physCharVelocity  = parameters.get<parameters::PHYS_CHAR_VELOCITY>();
  const T physCharViscosity = parameters.get<parameters::PHYS_CHAR_VISCOSITY>();
  const T physCharDensity   = parameters.get<parameters::PHYS_CHAR_DENSITY>();
  const T couplingG         = parameters.get<parameters::COUPLING_G>();
  latticeOne.setUnitConverter<UnitConverterFromResolutionAndRelaxationTime<T,DESCRIPTOR>>(
    N,
    tau,
    physCharLength,
    physCharVelocity,
    physCharViscosity,
    physCharDensity
  );

  auto& converter = latticeOne.getUnitConverter();
  converter.print();

  latticeTwo.setUnitConverter(converter);

  latticeOne.defineDynamics<ForcedShanChenBGKdynamics<T, DESCRIPTOR, momenta::ExternalVelocityTuple>>(geometry, 1);
  latticeOne.defineDynamics<ForcedShanChenBGKdynamics<T, DESCRIPTOR, momenta::ExternalVelocityTuple>>(geometry, 2);
  latticeOne.defineDynamics<ForcedShanChenBGKdynamics<T, DESCRIPTOR, momenta::ExternalVelocityTuple>>(geometry, 3);
  latticeOne.defineDynamics<ForcedShanChenBGKdynamics<T, DESCRIPTOR, momenta::ExternalVelocityTuple>>(geometry, 4);

  latticeTwo.defineDynamics<ForcedShanChenBGKdynamics<T, DESCRIPTOR, momenta::ExternalVelocityTuple>>(geometry, 1);
  latticeTwo.defineDynamics<ForcedShanChenBGKdynamics<T, DESCRIPTOR, momenta::ExternalVelocityTuple>>(geometry, 2);
  latticeTwo.defineDynamics<ForcedShanChenBGKdynamics<T, DESCRIPTOR, momenta::ExternalVelocityTuple>>(geometry, 3);
  latticeTwo.defineDynamics<ForcedShanChenBGKdynamics<T, DESCRIPTOR, momenta::ExternalVelocityTuple>>(geometry, 4);

  boundary::set<boundary::BounceBack>(latticeOne, geometry, 3);
  boundary::set<boundary::BounceBack>(latticeOne, geometry, 4);
  boundary::set<boundary::BounceBack>(latticeTwo, geometry, 3);
  boundary::set<boundary::BounceBack>(latticeTwo, geometry, 4);

  const T omega1  = converter.getLatticeRelaxationFrequency();
  const T omega2  = converter.getLatticeRelaxationFrequency();
  latticeOne.setParameter<descriptors::OMEGA>(omega1);
  latticeTwo.setParameter<descriptors::OMEGA>(omega2);

  using COUPLING = PseudopotentialForcedCoupling<
    interaction::PsiEqualsRho,
    multicomponent_velocity::ShanChen
  >;

  auto& coupling = myCase.setCouplingOperator(
    "MultiComponent",
    COUPLING{},
    names::A{}, latticeOne,
    names::B{}, latticeTwo
  );

  coupling.setParameter<COUPLING::G>(couplingG);
  coupling.setParameter<multicomponent_velocity::ShanChen::OMEGA_A>(omega1);
  coupling.setParameter<multicomponent_velocity::ShanChen::OMEGA_B>(omega2);

  latticeOne.addPostProcessor<stage::PreCoupling>(meta::id<RhoStatistics>());
  latticeTwo.addPostProcessor<stage::PreCoupling>(meta::id<RhoStatistics>());

  {
    auto& communicator = latticeOne.getCommunicator(stage::PreCoupling());
    communicator.requestOverlap(1);
    communicator.requestField<descriptors::STATISTIC>();
    communicator.exchangeRequests();
  }

  {
    auto& communicator = latticeTwo.getCommunicator(stage::PreCoupling());
    communicator.requestOverlap(1);
    communicator.requestField<descriptors::STATISTIC>();
    communicator.exchangeRequests();
  }

  clout << "Prepare Lattice ... OK" << std::endl;
}

void setInitialValues(MyCase& myCase) {
  OstreamManager clout(std::cout, "setInitialValues");
  clout << "Setting initial values ..." << std::endl;

  using T          = MyCase::value_t_of<Component1>;
  using DESCRIPTOR = MyCase::descriptor_t_of<Component1>;

  auto& geometry    = myCase.getGeometry();
  auto& latticeOne  = myCase.getLattice(Component1{});
  auto& latticeTwo  = myCase.getLattice(Component2{});
  auto& parameters  = myCase.getParameters();

  const T noiseVal        = parameters.get<parameters::NOISE>();
  const T zeroVal         = parameters.get<parameters::ZERO>();
  const T force           = parameters.get<parameters::FORCE>();
  const T ny              = parameters.get<parameters::DOMAIN_EXTENT>()[1];

  AnalyticalConst2D<T,T> noise( noiseVal );
  AnalyticalConst2D<T,T> zeroV(0., 0.);
  AnalyticalConst2D<T,T> zero( zeroVal );
  AnalyticalLinear2D<T,T> one( 0., -force * descriptors::invCs2<T,DESCRIPTOR>(), 0.98 + force * ny * descriptors::invCs2<T,DESCRIPTOR>() );
  AnalyticalConst2D<T,T> onePlus( 0.98 + force * ny / 2. * descriptors::invCs2<T,DESCRIPTOR>() );
  AnalyticalRandom2D<T,T> random;
  AnalyticalIdentity2D<T,T> randomOne( random * noise + one );
  AnalyticalIdentity2D<T,T> randomPlus( random * noise + onePlus );
  AnalyticalConst2D<T,T> f( 0, -force );

  // for each material set the defineRhou and the Equilibrium

  latticeOne.defineRhoU( geometry, 1, zero, zeroV );
  latticeOne.iniEquilibrium( geometry, 1, zero, zeroV );
  latticeOne.defineField<descriptors::EXTERNAL_FORCE>( geometry, 1, f );
  latticeTwo.defineRhoU( geometry, 1, randomPlus, zeroV );
  latticeTwo.iniEquilibrium( geometry, 1, randomPlus, zeroV );

  latticeOne.defineRhoU( geometry, 2, randomOne, zeroV );
  latticeOne.iniEquilibrium( geometry, 2, randomOne, zeroV );
  latticeOne.defineField<descriptors::EXTERNAL_FORCE>( geometry, 2, f );
  latticeTwo.defineRhoU( geometry, 2, zero, zeroV );
  latticeTwo.iniEquilibrium( geometry, 2, zero, zeroV );

  // Make the lattice ready for simulation
  latticeOne.initialize();
  latticeTwo.initialize();

  clout << "Setting initial values ... OK" << std::endl;
}

void setTemporalValues(MyCase& myCase,
                       std::size_t iT)
{
  // Nothing to do here
}

void getResults(MyCase& myCase,
                util::Timer<MyCase::value_t>& timer,
                std::size_t iT)
{
  OstreamManager clout(std::cout,"getResults");

  using T          = MyCase::value_t_of<Component1>;
  using DESCRIPTOR = MyCase::descriptor_t_of<Component1>;

  auto& latticeOne  = myCase.getLattice(Component1{});
  auto& latticeTwo  = myCase.getLattice(Component2{});
  auto& parameters  = myCase.getParameters();

  SuperVTMwriter2D<T> vtmWriter( "rayleighTaylor2dsLatticeOne" );

  const int vtkIter   = parameters.get<parameters::PHYS_VTK_ITER_T>();
  const int statIter  = parameters.get<parameters::PHYS_STAT_ITER_T>();

  if ( iT == 0 ) {
    // Writes the geometry, cuboid no. and rank no. as vti file for visualization
    SuperLatticeCuboid2D<T, DESCRIPTOR> cuboid( latticeOne );
    SuperLatticeRank2D<T, DESCRIPTOR> rank( latticeOne );
    vtmWriter.write( cuboid );
    vtmWriter.write( rank );
    vtmWriter.createMasterFile();
  }

  // Get statistics
  if ( iT % statIter == 0 && iT > 0 ) {
    // Timer console output
    timer.update( iT );
    timer.printStep();

    clout << "averageRhoFluidOne="   << latticeOne.getStatistics().getAverageRho();
    clout << "; averageRhoFluidTwo=" << latticeTwo.getStatistics().getAverageRho() << std::endl;
  }

  // Writes the VTK files
  if ( iT % vtkIter == 0 ) {
    latticeOne.setProcessingContext(ProcessingContext::Evaluation);
    latticeTwo.setProcessingContext(ProcessingContext::Evaluation);

    SuperLatticeVelocity2D<T, DESCRIPTOR> velocity( latticeOne );
    SuperLatticeDensity2D<T, DESCRIPTOR> density( latticeOne );
    vtmWriter.addFunctor( velocity );
    vtmWriter.addFunctor( density );
    vtmWriter.write( iT );

    BlockReduction2D2D<T> planeReduction( density, 600, BlockDataSyncMode::ReduceOnly );
    // write output as JPEG
    heatmap::write(planeReduction, iT);
  }
}

void simulate(MyCase& myCase) {
  OstreamManager clout(std::cout,"simulate");
  clout << "starting simulation..." << std::endl;

  using T = MyCase::value_t;
  auto& parameters  = myCase.getParameters();

  const int iTmax   = parameters.get<parameters::MAX_ITER>();

  util::Timer<T> timer(iTmax, myCase.getGeometry().getStatistics().getNvoxel());
  timer.start();

  for (int iT = 0; iT < iTmax; ++iT ) {

    setTemporalValues(myCase, iT);

    myCase.getLattice(Component1{}).collideAndStream();
    myCase.getLattice(Component2{}).collideAndStream();

    myCase.getLattice(Component1{}).executePostProcessors(stage::PreCoupling());
    myCase.getLattice(Component2{}).executePostProcessors(stage::PreCoupling());
    myCase.getOperator("MultiComponent").apply();

    getResults( myCase, timer, iT );
  }

  timer.stop();
  timer.printSummary();

  clout << "simulation finished ... Goodbye!" << std::endl;
}

int main(int argc, char* argv[]) {
  initialize(&argc, &argv);

  /// === Step 2: Set Parameters ===
  MyCase::ParametersD myCaseParameters;
  {
    using namespace olb::parameters;
    myCaseParameters.set<RESOLUTION>(800);
    myCaseParameters.set<ORIGIN>({0, 0});
    myCaseParameters.set<PHYS_DELTA_X>(1.);
    myCaseParameters.set<MAX_ITER>(20000);
    myCaseParameters.set<RHO_1>(0.0);
    myCaseParameters.set<RHO_2>(1.0);
    myCaseParameters.set<LATTICE_RELAXATION_TIME>(1.);
    myCaseParameters.set<PHYS_CHAR_LENGTH>(1e-5);
    myCaseParameters.set<PHYS_CHAR_VELOCITY>(1.e-6);
    myCaseParameters.set<PHYS_CHAR_VISCOSITY>(0.1);
    myCaseParameters.set<PHYS_CHAR_DENSITY>(1.);
    myCaseParameters.set<COUPLING_G>(3.);
    myCaseParameters.set<ZERO>(1.e-6);
    myCaseParameters.set<NOISE>(4.e-2);
    myCaseParameters.set<PHYS_VTK_ITER_T>(100);
    myCaseParameters.set<PHYS_STAT_ITER_T>(100);
  }
  myCaseParameters.set<parameters::DOMAIN_EXTENT>([&]() -> Vector<MyCase::value_t, 2> {
    return {static_cast<MyCase::value_t>(myCaseParameters.get<parameters::RESOLUTION>()),
            static_cast<MyCase::value_t>(myCaseParameters.get<parameters::RESOLUTION>() / 2)};
  });
  myCaseParameters.set<parameters::FORCE>([&]() -> MyCase::value_t {
    return 30. / (  myCaseParameters.get<parameters::DOMAIN_EXTENT>()[1]
                  * myCaseParameters.get<parameters::DOMAIN_EXTENT>()[1]);
  });
  myCaseParameters.fromCLI(argc, argv);

  /// === Step 3: Create Mesh ===
  Mesh mesh = createMesh(myCaseParameters);

  /// === Step 4: Create Case ===
  MyCase myCase(myCaseParameters, mesh);

  /// === Step 5: Prepare Geometry ===
  prepareGeometry(myCase);

  /// === Step 6: Prepare Lattice ===
  prepareLattice(myCase);

  /// === Step 7: Definition of Initial, Boundary Values, and Fields ===
  setInitialValues(myCase);

  /// === Step 8: Simulate ===
  simulate(myCase);
}

/*  Lattice Boltzmann sample, written in C++, using the OpenLB
 *  library
 *
 *  Copyright (C) 2025 Florian Kaiser
 *                2008 Orestis Malaspinas, Andrea Parmigiani
 *  E-mail contact: info@openlb.net
 *  The most recent release of OpenLB can be downloaded at
 *  <http://www.openlb.net/>
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public
 *  License along with this program; if not, write to the Free
 *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 *  Boston, MA  02110-1301, USA.
 */

/* rayleighTaylor2d.cpp:
 * Rayleigh-Taylor instability in 2D, generated by a heavy
 * fluid penetrating a light one. The multi-component fluid model
 * by X. Shan and H. Chen is used. This example shows the usage
 * of multicomponent flow and periodic boundaries.
 */


#include <olb.h>

using namespace olb;
using namespace olb::names;

// === Step 1: Declarations ===
using MyCase = Case<
  Component1, Lattice<float,
    descriptors::D3Q19<
      descriptors::FORCE,
      descriptors::EXTERNAL_FORCE,
      descriptors::STATISTIC
    >
  >,

  Component2, Lattice<float,
    descriptors::D3Q19<
      descriptors::FORCE,
      descriptors::EXTERNAL_FORCE,
      descriptors::STATISTIC
    >
  >
>;

/// @brief Create a simulation mesh, based on user-specific geometry
/// @return An instance of Mesh, which keeps the relevant information
Mesh<MyCase::value_t,MyCase::d> createMesh(MyCase::ParametersD& parameters) {
  using T = MyCase::value_t_of<Component1>;
  const Vector extent = parameters.get<parameters::DOMAIN_EXTENT>();
  const Vector origin = parameters.get<parameters::ORIGIN>();
  const T physDeltaX  = parameters.get<parameters::PHYS_DELTA_X>();
  IndicatorCuboid3D<T> cuboid(extent, origin);

  Mesh<T,MyCase::d> mesh(cuboid, physDeltaX, singleton::mpi().getSize());
  mesh.setOverlap(parameters.get<parameters::OVERLAP>());
  mesh.getCuboidDecomposition().setPeriodicity({true, false, true});
  return mesh;
}

void prepareGeometry(MyCase& myCase) {
  OstreamManager clout( std::cout,"prepareGeometry" );
  clout << "Prepare Geometry ..." << std::endl;

  using T = MyCase::value_t_of<Component1>;

  auto& geometry    = myCase.getGeometry();
  auto& parameters  = myCase.getParameters();

  const Vector extend     = parameters.get<parameters::DOMAIN_EXTENT>();
  const T dx              = parameters.get<parameters::PHYS_DELTA_X>();
  const T nx              = extend[0];
  const T ny              = extend[1];
  const T nz              = extend[2];

  // Sets material number for fluid and boundary
  geometry.rename( 0, 1 );

  Vector upperOrigin{          -dx, ny / (T) 2.,                 -dx };
  Vector upperExtend{ nx + 2. * dx, ny / 2.  + 2. * dx, nz + 2. * dx };
  IndicatorCuboid3D<T> upper( upperExtend, upperOrigin );
  geometry.rename( 1, 2, upper );

  Vector bottomOrigin{     -2. * dx, -2. * dx,     -2. * dx };
  Vector bottomExtend{ nx + 3. * dx,  2. * dx, nz + 3. * dx };
  IndicatorCuboid3D<T> bottom( bottomExtend, bottomOrigin );
  geometry.rename( 1, 3, bottom );

  Vector topOrigin{     -2. * dx, ny - 1. * dx,     -2. * dx};
  Vector topExtend{ nx + 3. * dx,      2. * dx, nz + 3. * dx };
  IndicatorCuboid3D<T> top( topExtend, topOrigin );
  geometry.rename( 2, 4, top );

  // Removes all not needed boundary voxels outside the surface
  //geometry.clean();
  // Removes all not needed boundary voxels inside the surface
  geometry.innerClean();
  geometry.checkForErrors();

  geometry.print();

  clout << "Prepare Geometry ... OK" << std::endl;
}

void prepareLattice(MyCase& myCase) {
  OstreamManager clout(std::cout,"prepareLattice");
  clout << "Prepare Lattice ..." << std::endl;

  using T          = MyCase::value_t_of<Component1>;
  using DESCRIPTOR = MyCase::descriptor_t_of<Component1>;

  auto& geometry   = myCase.getGeometry();
  auto& latticeOne = myCase.getLattice(Component1{});
  auto& latticeTwo = myCase.getLattice(Component2{});
  auto& parameters = myCase.getParameters();

  // The setup is: periodicity along horizontal direction, bounce-back on top
  // and bottom. The upper half is initially filled with fluid 1 + random noise,
  // and the lower half with fluid 2. Only fluid 1 experiences a forces,
  // directed downwards.

  const int N               = parameters.get<parameters::RESOLUTION>();
  const T tau               = parameters.get<parameters::LATTICE_RELAXATION_TIME>();
  const T physCharLength    = parameters.get<parameters::PHYS_CHAR_LENGTH>();
  const T physCharVelocity  = parameters.get<parameters::PHYS_CHAR_VELOCITY>();
  const T physCharViscosity = parameters.get<parameters::PHYS_CHAR_VISCOSITY>();
  const T physCharDensity   = parameters.get<parameters::PHYS_CHAR_DENSITY>();
  const T couplingG         = parameters.get<parameters::COUPLING_G>();
  latticeOne.setUnitConverter<UnitConverterFromResolutionAndRelaxationTime<T,DESCRIPTOR>>(
    N,
    tau,
    physCharLength,
    physCharVelocity,
    physCharViscosity,
    physCharDensity
  );

  auto& converter = latticeOne.getUnitConverter();
  converter.print();

  latticeTwo.setUnitConverter(converter);
  dynamics::set<ForcedShanChenBGKdynamics<T, DESCRIPTOR, momenta::ExternalVelocityTuple>>(latticeOne, geometry.getMaterialIndicator({ 1, 2, 3, 4 }));
  dynamics::set<ForcedShanChenBGKdynamics<T, DESCRIPTOR, momenta::ExternalVelocityTuple>>(latticeTwo, geometry.getMaterialIndicator({ 1, 2, 3, 4 }));

  boundary::set<boundary::BounceBack>(latticeOne, geometry, 3);
  boundary::set<boundary::BounceBack>(latticeOne, geometry, 4);
  boundary::set<boundary::BounceBack>(latticeTwo, geometry, 3);
  boundary::set<boundary::BounceBack>(latticeTwo, geometry, 4);

  const T omega1  = converter.getLatticeRelaxationFrequency();
  const T omega2  = converter.getLatticeRelaxationFrequency();
  latticeOne.setParameter<descriptors::OMEGA>(omega1);
  latticeTwo.setParameter<descriptors::OMEGA>(omega2);

  using COUPLING = PseudopotentialForcedCoupling<
    interaction::PsiEqualsRho,
    multicomponent_velocity::ShanChen
  >;

  auto& coupling = myCase.setCouplingOperator(
    "MultiComponent",
    COUPLING{},
    names::A{}, latticeOne,
    names::B{}, latticeTwo
  );

  coupling.setParameter<COUPLING::G>(couplingG);
  coupling.setParameter<multicomponent_velocity::ShanChen::OMEGA_A>(omega1);
  coupling.setParameter<multicomponent_velocity::ShanChen::OMEGA_B>(omega2);

  latticeOne.addPostProcessor<stage::PreCoupling>(meta::id<RhoStatistics>());
  latticeTwo.addPostProcessor<stage::PreCoupling>(meta::id<RhoStatistics>());

  {
    auto& communicator = latticeOne.getCommunicator(stage::PreCoupling());
    communicator.requestOverlap(1);
    communicator.requestField<descriptors::STATISTIC>();
    communicator.exchangeRequests();
  }

  {
    auto& communicator = latticeTwo.getCommunicator(stage::PreCoupling());
    communicator.requestOverlap(1);
    communicator.requestField<descriptors::STATISTIC>();
    communicator.exchangeRequests();
  }

  clout << "Prepare Lattice ... OK" << std::endl;
}

void setInitialValues(MyCase& myCase) {
  OstreamManager clout(std::cout, "setInitialValues");
  clout << "Setting initial values ..." << std::endl;

  using T          = MyCase::value_t_of<Component1>;
  using DESCRIPTOR = MyCase::descriptor_t_of<Component1>;

  auto& geometry    = myCase.getGeometry();
  auto& latticeOne  = myCase.getLattice(Component1{});
  auto& latticeTwo  = myCase.getLattice(Component2{});
  auto& parameters  = myCase.getParameters();

  const T noiseVal        = parameters.get<parameters::NOISE>();
  const T zeroVal         = parameters.get<parameters::ZERO>();
  const T force           = parameters.get<parameters::FORCE>();
  const T ny              = parameters.get<parameters::DOMAIN_EXTENT>()[1];

  AnalyticalConst3D<T,T> noise( noiseVal );
  AnalyticalLinear3D<T,T> one( 0., -force * descriptors::invCs2<T,DESCRIPTOR>(), 0., 0.98 + force * ny * descriptors::invCs2<T,DESCRIPTOR>() );
  AnalyticalConst3D<T,T> onePlus( 0.98 + force * ny / 2. * descriptors::invCs2<T,DESCRIPTOR>() );
  AnalyticalRandom3D<T,T> random;
  AnalyticalIdentity3D<T,T> randomOne( random * noise + one );
  AnalyticalIdentity3D<T,T> randomPlus( random * noise + onePlus );
  AnalyticalConst3D<T,T> f( 0., -force, 0. );

  // for each material set the defineRhou and the Equilibrium
  fields::set<descriptors::EXTERNAL_FORCE>(latticeOne, geometry.getMaterialIndicator({1,2}), f);
  momenta::setDensity(latticeOne, geometry.getMaterialIndicator(1), zeroVal);
  momenta::setDensity(latticeTwo, geometry.getMaterialIndicator(1), randomPlus);
  momenta::setDensity(latticeOne, geometry.getMaterialIndicator(2), randomOne);
  momenta::setDensity(latticeTwo, geometry.getMaterialIndicator(2), zeroVal);

  // Make the lattice ready for simulation
  latticeOne.initialize();
  latticeTwo.initialize();

  clout << "Setting initial values ... OK" << std::endl;
}

void setTemporalValues(MyCase& myCase,
                       std::size_t iT)
{
  // Nothing to do here
}

void getResults(MyCase& myCase,
                util::Timer<MyCase::value_t>& timer,
                std::size_t iT)
{
  OstreamManager clout(std::cout,"getResults");

  using T           = MyCase::value_t_of<Component1>;
  using DESCRIPTOR  = MyCase::descriptor_t_of<Component1>;

  auto& latticeOne  = myCase.getLattice(Component1{});
  auto& latticeTwo  = myCase.getLattice(Component2{});
  auto& parameters  = myCase.getParameters();

  SuperVTMwriter3D<T> vtmWriter( "rayleighTaylor3dLatticeOne" );

  const int vtkIter   = parameters.get<parameters::LATTICE_VTK_ITER_T>();
  const int statIter  = parameters.get<parameters::LATTICE_STAT_ITER_T>();
  const int maxIter   = parameters.get<parameters::MAX_LATTICE_T>();

  if ( iT == 0 ) {
    // Writes the geometry, cuboid no. and rank no. as vti file for visualization
    SuperLatticeCuboid3D<T, DESCRIPTOR> cuboid( latticeOne );
    SuperLatticeRank3D<T, DESCRIPTOR> rank( latticeOne );
    vtmWriter.write( cuboid );
    vtmWriter.write( rank );
    vtmWriter.createMasterFile();
  }

  // Get statistics
  if ( ( iT % statIter == 0 && iT > 0 ) || iT == maxIter) {
    // Timer console output
    timer.update( iT );
    timer.printStep();

    clout << "averageRhoFluidOne="   << latticeOne.getStatistics().getAverageRho();
    clout << "; averageRhoFluidTwo=" << latticeTwo.getStatistics().getAverageRho() << std::endl;
  }

  // Writes the VTK files
  if ( iT % vtkIter == 0 || iT == maxIter ) {
    latticeOne.setProcessingContext(ProcessingContext::Evaluation);
    latticeTwo.setProcessingContext(ProcessingContext::Evaluation);

    latticeOne.scheduleBackgroundOutputVTK([&,iT](auto task) {
      SuperVTMwriter3D<T> vtkWriter("rayleighTaylor3dLatticeOne");
      SuperLatticeVelocity3D velocity(latticeOne);
      SuperLatticeDensity3D density(latticeOne);
      vtkWriter.addFunctor(velocity);
      vtkWriter.addFunctor(density);
      task(vtkWriter, iT);
    });

    {
      SuperLatticeDensity3D density(latticeOne);
      BlockReduction3D2D<T> planeReduction(density, {0, 0, 1});
      // write output as JPEG
      heatmap::write(planeReduction, iT);
    }
  }
}

void simulate(MyCase& myCase) {
  OstreamManager clout(std::cout,"simulate");
  clout << "starting simulation..." << std::endl;

  using T = MyCase::value_t;
  auto& parameters  = myCase.getParameters();

  const std::size_t iTmax = parameters.get<parameters::MAX_LATTICE_T>();

  util::Timer<T> timer(iTmax, myCase.getGeometry().getStatistics().getNvoxel());
  timer.start();

  for (int iT = 0; iT < iTmax; ++iT ) {

    setTemporalValues(myCase, iT);

    myCase.getLattice(Component1{}).collideAndStream();
    myCase.getLattice(Component2{}).collideAndStream();

    myCase.getLattice(Component1{}).executePostProcessors(stage::PreCoupling());
    myCase.getLattice(Component2{}).executePostProcessors(stage::PreCoupling());
    myCase.getOperator("MultiComponent").apply();

    getResults( myCase, timer, iT );
  }

  timer.stop();
  timer.printSummary();

  clout << "simulation finished ... Goodbye in 3D!" << std::endl;
}

int main(int argc, char* argv[]) {
  initialize(&argc, &argv);

  /// === Step 2: Set Parameters ===
  MyCase::ParametersD myCaseParameters;
  {
    using namespace olb::parameters;
    using T = MyCase::value_t;
    myCaseParameters.set<RESOLUTION>(200);
    myCaseParameters.set<ORIGIN>({0, 0, 0});
    myCaseParameters.set<PHYS_DELTA_X>((T) 1.);
    myCaseParameters.set<MAX_LATTICE_T>(10000);
    myCaseParameters.set<RHO_1>((T) 0.0);
    myCaseParameters.set<RHO_2>((T) 1.0);
    myCaseParameters.set<LATTICE_RELAXATION_TIME>((T) 1.);
    myCaseParameters.set<PHYS_CHAR_LENGTH>((T) 1e-5);
    myCaseParameters.set<PHYS_CHAR_VELOCITY>((T) 1.e-6);
    myCaseParameters.set<PHYS_CHAR_VISCOSITY>((T) 0.1);
    myCaseParameters.set<PHYS_CHAR_DENSITY>((T) 1.);
    myCaseParameters.set<COUPLING_G>((T) 3.);
    myCaseParameters.set<ZERO>((T) 1.e-6);
    myCaseParameters.set<NOISE>((T) 4.e-2);
    myCaseParameters.set<LATTICE_VTK_ITER_T>((T) 500);
    myCaseParameters.set<LATTICE_STAT_ITER_T>((T) 100);
    myCaseParameters.set<parameters::DOMAIN_EXTENT>([&]() -> Vector<MyCase::value_t, 3> {
      return{
        (T) myCaseParameters.get<parameters::RESOLUTION>(),
        (T) myCaseParameters.get<parameters::RESOLUTION>() / (T)2.,
        (T) myCaseParameters.get<parameters::RESOLUTION>()
      };
    });
    myCaseParameters.set<parameters::FORCE>([&]() -> MyCase::value_t {
      return 7.0 / (myCaseParameters.get<parameters::DOMAIN_EXTENT>()[1] * myCaseParameters.get<parameters::DOMAIN_EXTENT>()[1]);
    });
  }
  myCaseParameters.fromCLI(argc, argv);

  /// === Step 3: Create Mesh ===
  Mesh mesh = createMesh(myCaseParameters);

  /// === Step 4: Create Case ===
  MyCase myCase(myCaseParameters, mesh);

  /// === Step 5: Prepare Geometry ===
  prepareGeometry(myCase);

  /// === Step 6: Prepare Lattice ===
  prepareLattice(myCase);

  /// === Step 7: Definition of Initial, Boundary Values, and Fields ===
  setInitialValues(myCase);

  /// === Step 8: Simulate ===
  simulate(myCase);
}
